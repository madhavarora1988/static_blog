
# How to Get Started with Model Context Protocol

> **TL;DR**  
> Spin up a local SQLite MCP server, point your favourite LLM at it, and start talking SQLâ€”in under five minutes.

![alt text](<Pasted image 20250505173159.png>)
Source: Generated by Dall-E 3

## Introduction

Large language models shine when they can **reason over real data**, but handing them unfettered access to your production database is... well, terrifying. Enter **Model Context Protocol (MCP)**: a lightweight, toolâ€‘based contract that lets you expose _just the right capabilities_ (readâ€‘only queries, schema discovery, feedback collection, etc.) in a way that models can understand and invoke safely.

In this guide weâ€™ll walk through a minimal proofâ€‘ofâ€‘concept (POC) MCP server built with **FastMCP** and SQLite. Weâ€™ll cover:

- Setting up the server and sample database
    
- Exploring the custom tools we defined (execute_query, describe_tableâ€¦)
    
- Connecting the server to Claude Desktop for interactive querying
    
- Ideas for extending the POC into something productionâ€‘ready
    

The code is public on [GitHub](https://github.com/madhavarora1988/mcp_sqlite_poc) â€” clone it, follow along, and drop questions in the comments if anything feels off.

## What is the Model Context Protocol?

On **NovemberÂ 25,Â 2024** Anthropic openâ€‘sourced MCP, positioning it as a universal bridge between AI assistants and the systems where real data livesâ€”content repositories, business apps, dev environments, you name it. Instead of writing a bespoke connector for every new data source, you expose a small set of JSONâ€‘described tools on an **MCP server** and let any **MCP client** (Claude Desktop, an agent framework, your own script) call them.

**Why the fuss?**

- **Open, twoâ€‘way standard** â€” secure, structured requests _and_ responses flow between models and data stores.
    
- **Server / client split** â€” run a tiny server next to your database (Postgres, Git, Slack, GoogleÂ Driveâ€¦), point the model at it, and youâ€™re done. No extra glue.
    
- **Ecosystem out of the gate** â€” Anthropic shipped readyâ€‘made servers for GoogleÂ Drive, Slack, GitHub, Postgres, and Puppeteer; early adopters like Block and Apollo already have MCP in production.
    
- **Firstâ€‘class in Claude Desktop** â€” local servers autoâ€‘register so you can chat with your data straight from the desktop app.
    
- **Not just databasesÂ â€” remote APIs too.** MCP servers can wrap any REST, GraphQL, or gRPC service (Stripe, Jira, your own microservice), letting models hit cloud APIs exactly like local tables.
    
- **Communityâ€‘driven** â€” spec, SDKs, and reference implementations all live in public reposâ€”pull requests welcome.
    

With that backdrop, letâ€™s zoom in on our SQLite demo and see where MCP really shines.

### General architecture

MCP follows a simple **clientÂ â†”Â server** pattern that scales from your laptop to the cloud:
![alt text](<Pasted image 20250505141259.png>)
Source: [https://modelcontextprotocol.io/introduction](https://modelcontextprotocol.io/introduction)

|Component|Role|
|---|---|
|**MCPÂ Host**|The UI or agent (ClaudeÂ Desktop, your IDE) that wants context|
|**MCPÂ Client**|Maintains a 1â€‘toâ€‘1 connection with a server, handling auth & retries|
|**MCPÂ Server**|Lightweight process that exposes domainâ€‘specific tools via JSON|
|**LocalÂ Data Source**|Files, DBs, or services the server can access on your machine|
|**RemoteÂ Service**|External API the server can proxy (e.g., Stripe, Jira)|

A single host can juggle multiple servers at onceâ€”imagine ClaudeÂ Desktop chatting with your local SQLite DB, a Git repo, and a SaaS ticketing API simultaneously.

> **What weâ€™ll build in this article:** weâ€™re going to implement the **MCPÂ Server** blockâ€”highlighted aboveâ€”using Python, FastMCP, and SQLite. By the end youâ€™ll have a fullyâ€‘functioning server that exposes database tools the host (ClaudeÂ Desktop) can call in real time.

---

## In a Hurry?

If you just want to run the demo locally, the quickâ€‘start is:

```bash
# 1. Clone the repo
git clone https://github.com/madhavarora1988/mcp_sqlite_poc.git
cd mcp_sqlite_poc

# 2. Install dependencies
pip install -r requirements.txt

# 3. (Optional) generate a fresh SQLite DB with sample tables & rows
python generate_sample_db.py

# 4. Fire up the MCP server (readâ€‘only by default)
python server.py
```

By default the server listens on **stdio**, which is exactly what Claude Desktop expects when it autoâ€‘detects local MCP servers. If youâ€™d rather expose an HTTP port, simply change the `transport` parameter in `app.run_async()`.

## Understanding the POC

### Project layout

```text
.
â”œâ”€â”€ generate_sample_db.py  # creates sample.db with metrics, users, ordersâ€¦
â”œâ”€â”€ requirements.txt       # FastMCP, aiosqlite, pydanticâ€¦
â”œâ”€â”€ server.py              # the SQLite MCP server
â””â”€â”€ README.md              # extended docs & Env vars
```

**generate_sample_db.py** bootstraps a realistic eâ€‘commerce schema with products, orders, and an `order_analytics` view so you have something to query straight away.  
**server.py** exposes six MCP tools and handles validation, logging, and optional readâ€‘only mode.

### Key safety features

- **Readâ€‘only toggle** â€“ controlled via the `READ_ONLY` env var (defaults to `true`).
    
- **`validate_query()`** â€“ rejects any SQL that starts with or contains risky verbs (`DROP`, `PRAGMA`, `ATTACH`, etc.) before it touches the database.
    
- **Paramâ€‘sanitised inserts** â€“ when `READ_ONLY` is `false`, sampleâ€‘data helpers still use parameterised statements to avoid injection.
    

### Available tools

|Tool|Purpose|Typical Payload|
|---|---|---|
|`execute_query`|Run a SELECT (or safe write) statement|`{"query": "SELECT * FROM products LIMIT 3;"}`|
|`list_tables`|See what objects are available|`{}`|
|`describe_table`|Get column names and types|`{"table_name": "orders"}`|
|`count_rows`|Quick row count|`{"table_name": "order_items"}`|
|`insert_sample_data`|Populate demo rows (writeâ€‘mode only)|`{"table_name": "customers", "count": 10}`|
|`add_feedback`|Collect user feedback|`{"user": "Alice", "email": "...", "feedback": "Great!"}`|

Feel free to extend this list with your own domainâ€‘specific toolsâ€”just decorate an async function with `@app.tool("my_tool")` and FastMCP will handle the schema for you.

## Testing in Claude Desktop

ClaudeÂ Desktop automatically scans its configuration file for MCP servers and makes them available in any chat. On macOS youâ€™ll find (or create) that file here:

```
~/Library/Application Support/Claude/claude_desktop_config.json
```

Append (or merge) the following block so Claude knows how to start our SQLite server:

```json
{
  "mcpServers": {
    "sqlite": {
      "command": "<absolute uv path>",
      "args": [
        "--directory",
        "<Path to workspace>",
        "run",
        "server.py"
      ]
    }
  }
}
```

- **`<absolute uv path>`** â€“ full path to the **uv** executable (e.g. `/usr/local/bin/uv`).
    
- **`<Path to workspace>`** â€“ folder that contains `server.py`, `generate_sample_db.py`, and `sample.db`.
    

Save the fileâ€”if the path didnâ€™t exist, macOS will create the `Claude` directory chain automaticallyâ€”then **restart ClaudeÂ Desktop**, and you should see **sqlite** listed in the leftâ€‘hand _Context_ panel. Youâ€™ll also notice a small _hammerÂ icon_ with a count (e.g. **6**) that reads **â€œMCP tools availableâ€** when you hoverâ€”proof that the server registered correctly (see ScreenshotÂ 1 below).

![alt text](<Pasted image 20250505141228.png>)
Source: Image byÂ Author

Click that icon and Claude pops up a modal detailing every tool your server exposed (ScreenshotÂ 2). From here you can doubleâ€‘check descriptionsâ€”or skip ahead to the **Example interactive query** section below to watch a full conversation in action.

![alt text](<Pasted image 20250505141156.png>)
Available Tools(Source: Image byÂ Author)

### Example interactive query

Once the tools show up you can chat naturally, and Claude will chain the right calls for you. In the screenshots below I asked three followâ€‘up questions:

1. **"Can you check how many orders were placed?"** â€“ Claude inspected the schema with `list_tables`, used `count_rows`, and reported **7 orders**.

![alt text](<Pasted image 20250427195246.png>)
Source:Image byÂ Author
    
2. **"Yes, who placed them?"** â€“ Claude peeked at table schemas (`describe_table`), executed a join via `execute_query`, and returned a customerâ€‘byâ€‘customer breakdown. 
![alt text](<Pasted image 20250427195300.png>)
Source:Image byÂ Author
    
3. **"User John says "This product is awesome"Â â€” please update the associated table."** â€“ Claude validated the schema again and invoked `add_feedback` to insert the comment into the **feedback** table, confirming success with the returned ID.

![alt text](<Pasted image 20250427195557.png>)
Source: Image byÂ Author
    

> ğŸ’¡Â Notice how the assistant narrates each tool invocation, so you can audit exactly what was run.

Feel free to riff on this flowâ€”ask for the most expensive order, daily sales totals, add new rows (with readâ€‘only off), or fetch inactive users and watch the model stitch together the correct SQL on the fly.

---

## Putting It All Together

1. **Spin up the server** â€“ local, container, or cloud function.
    
2. **Add it to your model config** â€“ Claude Desktop, Anthropic SDK, LangChain, etc.
    
3. **Let the model explore the schema** â€“ start with `list_tables()` and `describe_table()`.
    
4. **Iterate** â€“ add domainâ€‘specific tools (e.g., `forecast_sales`, `flag_anomaly`) as your useâ€‘case grows.
    
5. **Lock it down** â€“ once happy, switch the DB to readâ€‘only or point the server at a replica.
    

## Suggestions

- **Keep it small.** Only expose tables the model genuinely needs (views are great for this).
    
- **Log aggressively.** The demo prints every query with user/time stampsâ€”pipe that into Loki or CloudWatch in prod.
    
- **Fail loudly.** If a malformed query sneaks past validation, raise a clear error so the model can retry with a better prompt.
    
- **Document tool semantics.** Use the `description` field in `@app.tool` to teach the model what each action does.
    

## Conclusion

Model Context Protocol turns the vague idea of â€œlet the LLM hit the databaseâ€ into a concrete, enforceable contract. With less than 200 lines of Python weâ€™ve wired up authenticationâ€‘free SQLite access, safe query validation, and a friendly tool catalogue the model can browse. Give the POC a whirl, customise it for your own datasets, and let me know in the comments what you build!